# 3.3 Processes and Threads

- [3.3.1 프로세스와 컴파일 과정](#331-프로세스와-컴파일-과정)
  - [전처리](#전처리)
  - [컴파일러](#컴파일러)
  - [어셈블러](#어셈블러)
  - [링커](#링커)
- [3.3.2 프로세스의 상태](#332-프로세스의-상태)
  - [생성 상태(create)](#생성-상태create)
  - [대기 상태(ready)](#대기-상태ready)
  - [대기 중단 상태(ready suspended)](#대기-중단-상태ready-suspended)
  - [실행 상태(running)](#실행-상태running)
  - [중단 상태(blocked)](#중단-상태blocked)
  - [종료 상태(stopped)](#종료-상태stopped)
- [3.3.3 프로세스의 메모리 구조](#333-프로세스의-메모리-구조)
  - [스택과 힙](#스택과-힙)
  - [데이터 영역과 코드 영역](#데이터-영역과-코드-영역)
- [3.3.4 PCB(Process Control Block)](#334-pcbprocess-control-block)
  - [PCB의 구조](#pcb의-구조)
  - [컨텍스트 스위칭(context switching)](#컨텍스트-스위칭context-switching)
- [3.3.5 멀티프로세싱](#335-멀티프로세싱)
  - [웹 브라우저](#웹-브라우저)
  - [IPC(Inter Process Communication)](#ipcinter-process-communication)
- [3.3.6. 스레드와 멀티 스레딩](#336-스레드와-멀티-스레딩)
  - [스레드](#스레드)
  - [멀티 스레딩](#멀티-스레딩)
- [3.3.7 공유 자원과 임계영역](#337-공유-자원과-임계영역)
  - [공유자원(shared resource)](#공유자원shared-resource)
  - [임계 영역(critical section)](#임계-영역critical-section)
  - [멀티 스레딩](#멀티-스레딩)
- [3.3.8 교착 상태(deadlock)](#338-교착-상태deadlock)
  - [교착상태 원인](#교착상태-원인)
  - [교착 상태의 해결 방법](#교착-상태의-해결-방법)
<br/>

---


# 3.3.1 프로세스와 컴파일 과정
- 프로세스(process) : 컴퓨터에서 실행되고 있는 프로그램. CPU 스케쥴링의 대상이 되는 작업(task)와 거의 같은 의미
- 스레드(thread) : 프로세스 내 작업의 흐름
- 프로그램이 메모리에 올라가면 인스턴스화가(프로세스가 됨) 일어나고, 이후에 OS의 CPU 스케쥴러에 의해 CPU가 프로세스를 실행한다.
- 프로그램 컴파일 과정 : 소스코드 --> 전처리 --> 컴파일러 --> 어셈블리어 --> 어셈블러 --> 목적코드 + 라이브러리 --> 링커 --> 실행파일


## 전처리
- 소스코드 주석 제거, 헤더파일 병합하여 매크로 치환

## 컴파일러
- 오류 처리, 코드 최적화 작업을 하며 어셈블리어로 변환

## 어셈블러
- 어셈블리어를 object code로 변환 (리눅스에서는 확장자가 .o)

## 링커
- 프로그램 내에 있는 라이브러리 함수 또는 다른 파일들과 목적 코드를 결합하여 실행파일을 생성함
- 실행파일은 exe나 out 확장자를 갖는다.

### 정적 라이브러리와 동적 라이브러리
- **정적 라이브러리**
  - 프로그램 빌드 시 라이브러리가 제공하는 모든 코드를 실행 파일에 넣는 방식으로 라이브러리를 사용
  - 외부 의존도는 낮음
  - 코드 중복 등 메모리 효율이 떨어짐
- **동적 라이브러리**
  - 프로그램 실행 시 필요할 때만 DLL의 함수 정보를 참조하여 라이브러리를 사용
  - 메모리 효율이 좋음
  - 외부 의존도가 높아짐

<br/>

---

# 3.3.2 프로세스의 상태
## 생성 상태(create)
- 프로세스가 생성된 상태
- fork()나 exec() 함수를 통해 생성
- 이 때 PCB가 할당된다.
  - fork() : 부모 프로세스의 주소 공간을 그대로 복사해서 새 자식 프로세스를 생성하는 함수. 주소만 복사하기 때문에 부모 프로세스의 비동기 작업 등을 상속하지는 않는다.
  - exec() : 새롭게 프로세스를 생성하는 함수

## 대기 상태(ready)
- 메모리 공간이 충분하면 메모리를 할당받고, 그렇지 않으면 대기
- CPU 스케쥴러로부터 CPU 소유권이 넘어오기를 기다림

## 대기 중단 상태(ready suspended)
- 메모리 부족으로 일시 중단된 상태

## 실행 상태(running)
- CPU 소유권과 메모리를 할당받고 인스트럭션을 수행 중인 상태
- CPU burst가 일어났다고도 표현함

## 중단 상태(blocked)
- 어떤 이벤트가 발생한 이후, 기다리며 프로세스가 차단된 상태
- I/O 인터럽트로 이런 현상이 많이 발생한다.

## 종료 상태(stopped)
- 메모리와 CPU 소유권을 모두 놓고 가는 상태
- 자연 종료 외에도 부모 프로세스가 자식 프로세스를 강제시키는 비자발적 종료(abort)로 종료되는 것도 있음
- 자식 프로세스에 할당된 자원 한계치를 넘거나, 부모 프로세스가 종료되거나 사용자가 process.kill등 명령어로 종료시킬 때 발생함.

<br/>

---

# 3.3.3 프로세스의 메모리 구조
## 스택과 힙
- 동적 할당 됨. 런타임 단계에서 메모리 할당.
- 스택은 위 주소부터, 힙은 아래주소부터 할당
### 스택(stack)
- 지역변수, 매개 변수, 실행될 함수에 의해 늘어나거나 줄어드는 메모리 영역
- 함수가 호출될 때마다 호출도리 때의 환경 등 특정 정보가 계속 저장된다.
- 재귀 함수 호출 시 새로운 스택 프레임이 매번 사용되기 때문에 함수 내 변수 집합이 해당 함수의 다른 인스턴스 변수를 방해하지 않는다.
### 힙(heap)
- 동적으로 할당되는 변수를 담고 있음
- malloc, free 함수를 통해 관리
- 동적으로 관리되는 자료구조의 경우 힙을 사용(ex. vector는 내부적으로 힙 사용)

## 데이터 영역과 코드 영역
- 정적으로 할당되는 영역. 컴파일 단계에서 메모리 할당.
### 데이터 영역(BSS segment, data segment)
- **BSS Segment** : 전역변수/static/const로 선언되어 있으며 0으로 할당되거나 어떤 값으로도 초기화되지 않은 변수들이 할당됨
- **Data Segment** : 전역변수/static/const로 선언되어 있으며 0으로 할당되지 않고 값으로 초기화된 변수들이 할당됨

### 코드 영역(code Segment)
- **code/text Segment** : 프로그램의 코드 저장


<br/>

---

# 3.3.4 PCB(Process Control Block)
- OS에서 프로세스에 대한 메타데이터를 저장한 데이터
- 프로세스 제어 블록이라고도 부름
- 프로세스 생성 시 OS가 해당 프로세스의 PCB를 생성
  1. 프로그램 실행 시 프로세스 생성
  2. 프로세스 주소 값에 앞서 스택, 힙 등등의 구조를 기반으로 메모리 할당 
  3. 프로세스 메타데이터들이 PCB에 저장되어 관리됨. 중요 정보가 포함되어 있기 때문에 커널 스택 맨 앞에서 관리함.

## PCB의 구조
- **프로세스 스케쥴링 상태** : 준비, 일시정지 등 프로세스가 CPU 소유권을 얻은 후의 상태
- **프로세스ID** : 프로세스 ID, 자식 프로세스ID
- **프로세스 권한** : 컴퓨터 자원 또는 I/O 디바이스 권한 정보
- **프로그램 카운터** : 프로세스에서 실행해야 할 다음 명령어 주소에 대한 포인터
- **CPU 레지스터** : 프로세스를 실행하기 위해 저장해야 할 레지스터에 대한 정보
- **CPU 스케줄링 정보** : CPU 스케줄러에 의해 중단된 시간 등 정보
- **계정 정보** : 프로세스 실행에 사용된 CPU 사용량, 실행 유저 정보
- **I/O 상태 정보** : 프로세스에 할당된 I/O 디바이스 목록

## 컨텍스트 스위칭(context switching)
- 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생
- 현대는 멀티코어 CPU지만, 싱글코어 기준으로 설명함
- 프로세스 A에서 B로 스위칭 되는 경우의 인터럽트/시스템콜
  1. A가 실행 중 상태에서 멈추고, A의 PCB를 저장하고 B의 PCB를 로드한다. (그 동안 B는 유휴시간을 가짐.)
  2. B를 실행한 다음 다시 B의 PCB를 저장하고, A의 PCB를 로드함.

### 캐시미스
- 컨텍스트 스위칭이 일어날 때 프로세스가 가지고 있는 메모리 주소가 그대로이면 잘못된 주소 변환이 발생함
- 캐시 클리어 과정을 겪기 때문에 캐시미스 발생

### 스레드에서의 컨텍스트 스위칭
- 스레드는 스택 영역을 제외한 모든 메모리를 공유하기 때문에, 스레드 컨텍스트 스위칭의 경우 비용, 시간이 적음.

<br/>

---

# 3.3.5 멀티프로세싱
- 여거 프로세스를 통해 동시에 두 가지 이상의 일을 수행하는 것
- 프로세스 일부가 문제가 생기더라도, 다른 프로세스를 통해 처리할 수 있어서 신뢰성이 높다

## 웹 브라우저
- **브라우저 프로세스** : 주소 표시줄, 북마크 막대, 뒤로가기, 앞으로가기 버튼 등의 작업. 네트워크 요청이나 파일 접근 권한 담당.
- **렌더러 프로세스** : 웹 사이트 내 보이는 부분의 모든 것을 제어
- **플러그인 프로세스** : 웹 사이트에서 사용하는 플러그인 제어
- **GPU 프로세스** : GPU를 이용해서 화면에 그리는 부분을 제어


## IPC(Inter Process Communication)
- IPC는 프로세스끼리 데이터를 주고받고 공유데이터를 관리하는 메커니즘
- 멀티 프로세스는 IPC가 가능함
- 공유 메모리, 파일, 소켓, 익명 파이프, 명명 파이프, 메세지 큐 등이 있음.

### 공유 메모리(shared memory)
- 동일한 메모리 블록에 여러 프로세스들의 접근 권한이 부여되어, 프로세스 간 서로 통신할 수 있도록 공유 메모리를 생성해서 통신하는 것
- 같은 메모리를 공유하기 때문에 오버헤드가 발생하지 않아 가장 빠름
- 여러 프로세스가 공유하기 때문에 동기화 필요
- 하드웨어 관점에서의 공유메모리는 CPU가 접근할 수 있는 RAM을 지칭하기도 함.

### 파일
- 디스크에 저장된 데이터, 파일 서버에서 제공한 데이터

### 소켓
- 동일 컴퓨터의 다른 프로세스나 네트워크 내 다른 컴퓨터로 네트워크 인터페이스를 통해 전송하는 데이터를 의미
- TCP/UDP가 있음.

### 익명 파이프(unnamed pipe)
- 프로세스 간 FIFO 방식으로 읽히는 임시 공간인 파이프를 기반으로 데이터를 주고받음
- 단방향 방식의 읽기전용, 쓰기전용 파이프를 만들어서 작동함
  - 부모 자식간만 가능. 다른 네트워크 X

### 명명 파이프(named pipe)
- 파이프 서버와 하나 이상의 파이프 클라이언트간의 통신을 위해 명명된 단/양방향 파이프
- 클라/서버 통신을 위한 별도 파이프를 제공
- 여러 파이프 동시 사용 가능
- 컴퓨터 프로세스 간 or 다른 네트워크 상의 컴퓨터와도 통신 가능

### 메세지 큐(message queue)
- 메세지를 큐 구조로 관리
- 커널에서 전역으로 관리
- 다른 IPC 방식에 비해 사용방법이 매우 직관적이고 간단함
- 장점 : 다른 코드 수정 없이 몇 줄로 간단하게 메세지 큐에 접근할 수 있음
- 공유 메모리를 통해 IPC 구현 시 읽기/쓰기 빈도가 높으면 동기화 땜누에 구현이 복잡해지는데, 이 때 대안으로 메세지 큐를 사용하기도 한다.

<br/>

---

# 3.3.6. 스레드와 멀티 스레딩
## 스레드
- 프로세스의 가장 실행가능한 작은 단위
- 코드/데이터/스택/힙을 생성하는 프로세스와는 달리 스레드는 코드/데이터/힙을 스레드끼리 공유한다.

## 멀티 스레딩
- 작업 내의 여러 개의 스레드를 처리하는 기법
- 스레드끼리 자원을 공유하기 때문에 효율이 높음
- 웹 요청 시 새 프로세스가 아닌 스레드를 사용하는 웹서버의 경우 리소스를 적게 사용하고, 한 스레드가 중단(block)되어도 다른 스레드는 실행(running)상태일 수 있어서 빠른 처리 가능
  - ex. 웹 브라우저의 렌더러 스레드 : 렌더러 프로세스를 이루는 스레드
    - 메인스레드
    - 워커 스레드
    - 컴포지터 스레드(레이어 합성)
    - 레스터 스레드(화면을 픽셀로 변환)
- 동시성(독립적인 작은 단위의 작업들을 동시에 실행되는 것처럼 보이는 것)에도 장점이 있음
- 하지만 한 스레드가 고장나면 다른 스레드에도 영향을 끼침

<br/>

---

# 3.3.7 공유 자원과 임계영역
## 공유자원(shared resource)
- 시스템 안에서 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일 데이터등의 자원이나 변수를 의미
- 경쟁 상태(race condition) : 두 개 이상의 프로세스가 동시에 읽기/쓰기 하는 상황

## 임계 영역(critical section)
- 둘 이상의 프로세스, 스레드가 공유자원에 접근할 때 순서 등의 이유로 결과가 달라지는 코드영역
- 임계 영역 해결법 : 뮤텍스, 세마포어, 모니터
- lock을 기반으로 함. 한정 대기, 융통성, 상호배제 조건을 만족시킨다.
  - **상호 배제** : 한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없다.
  - **한정 대기** : 특정 프로세스가 영원히 임계 영역에 들어가지 못하면 안 된다.
  - **융통성** : 한 프로세스가 다른 프로세스의 일을 방해해서는 안 된다.

### 뮤텍스(mutex)
- 프로세스나 스레드가 공유자원을 lock()을 통해 잠금 설정, 사용 후에는 unlock()으로 잠금을 해제 하는 객체
- 잠금이 설정되면 다른 프로세스/스레드가 잠긴 영역에 접근할 수 없음.
- 잠금과 잠금해제 상태 2가지만을 가진다.


### 세마포어(semaphore)
- 일반화된 뮤텍스
- 간단한 정수값과 두 가지 함수(wait(P함수), signal(V함수))로 공유 자원에 대한 접근 처리
  - wait() : 자신의 차례가 올 때가지 기다리는 함수
  - signal() : 다음 프로세스로 순서를 넘겨주는 함수
- 프로세스/스레드가 공유자원에 접근하면 세마포어에서 wait() 작업 수행, 해제 시 signal() 수행
- 세마포어는 조건 변수가 없고, 프로세스/스레드가 세마포어 값을 수정할 때 다른 프로세스/스레드는 세마포어 값을 변경할 수 없다.
  - **바이너리 세마포어** : 0, 1 두 가지 값만 가짐. 뮤텍스와 유사하지만 뮤텍스는 잠금 메커니즘이고 세마포어는 신호 매커니즘이다.
  - **카운팅 세마포어** : 여러 개의 값을 가질 수 있는 세마포어. 여러 자원에 대한 접근을 제어하는데 사용

### 모니터(monitor)
- 둘 이상의 스레드/프로세스가 공유 자원에 안전하게 접근할 수 있도록, 공유 자원을 숨기고 접근 인터페이스만 제공
- 모니터큐를 통해 공유 자원에 대한 작업을 순차적으로 처리
- 세마포어보다 구현이 쉬움
  - 모니터는 상호 배제가 자동으로 설정됨.
  - 세마포어는 직접 명시적으로 구현해야 한다.

<br/>

---

# 3.3.8 교착 상태(deadlock)
- 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태
## 교착상태 원인
- **상호 배제** : 한 프로세스가 자원을 독점하고 있으며 다른 프로세스들은 접근이 불가능함.
- **점유 대기** : 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하는 형태
- **비선점** : 다른 프로세스의 자원을 강제적으로 가져올 수 없음
- **환영 대기** : 프로세스 A가 B의 자원을 요구하고, 프로세스 B는 A의 자원을 요구하여 서로가 서로의 자원을 요구하는 상황

## 교착 상태의 해결 방법
1. 자원을 할당할 때 애초에 조건이 성립되지 않도록 설계
2. 교착 상태 가능성이 없을 때만 자원을 할당함. 프로세스 당 요청할 자원들의 최대치를 통해, 자원 할당 가능 여부를 파악하는 은행원 알고리즘을 사용
   - **은행원 알고리즘** : 총 자원의 양과 현재 할당한 자원의 양을 기준으로, 안정/불안정 상태로 나누고, 안정상태로 갈 수 있도록 자원을 할당하는 알고리즘
3. 교착 상태가 발생하면 싸이클이 있는지 확인하고, 관련된 프로세스를 하나씩 지움
4. 교착 상태가 드물게 일어나기 때문에 처리비용이 더 커서, OS가 교착상태 발생 시 사용자에게 작업 종료하게 한다.