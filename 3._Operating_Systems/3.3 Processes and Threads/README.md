# 3.3 Processes and Threads

- [3.3.1 프로세스와 컴파일 과정](#331-프로세스와-컴파일-과정)
  - [전처리](#전처리)
  - [컴파일러](#컴파일러)
  - [어셈블러](#어셈블러)
  - [링커](#링커)
- [3.3.2 프로세스의 상태](#332-프로세스의-상태)
  - [생성 상태(create)](#생성-상태create)
  - [대기 상태(ready)](#대기-상태ready)
  - [대기 중단 상태(ready suspended)](#대기-중단-상태ready-suspended)
  - [실행 상태(running)](#실행-상태running)
  - [중단 상태(blocked)](#중단-상태blocked)
  - [종료 상태(stopped)](#종료-상태stopped)

    

<br/>

---


# 3.3.1 프로세스와 컴파일 과정
- 프로세스(process) : 컴퓨터에서 실행되고 있는 프로그램. CPU 스케쥴링의 대상이 되는 작업(task)와 거의 같은 의미
- 스레드(thread) : 프로세스 내 작업의 흐름
- 프로그램이 메모리에 올라가면 인스턴스화가(프로세스가 됨) 일어나고, 이후에 OS의 CPU 스케쥴러에 의해 CPU가 프로세스를 실행한다.
- 프로그램 컴파일 과정 : 소스코드 --> 전처리 --> 컴파일러 --> 어셈블리어 --> 어셈블러 --> 목적코드 + 라이브러리 --> 링커 --> 실행파일


## 전처리
- 소스코드 주석 제거, 헤더파일 병합하여 매크로 치환

## 컴파일러
- 오류 처리, 코드 최적화 작업을 하며 어셈블리어로 변환

## 어셈블러
- 어셈블리어를 object code로 변환 (리눅스에서는 확장자가 .o)

## 링커
- 프로그램 내에 있는 라이브러리 함수 또는 다른 파일들과 목적 코드를 결합하여 실행파일을 생성함
- 실행파일은 exe나 out 확장자를 갖는다.

### 정적 라이브러리와 동적 라이브러리
- **정적 라이브러리**
  - 프로그램 빌드 시 라이브러리가 제공하는 모든 코드를 실행 파일에 넣는 방식으로 라이브러리를 사용
  - 외부 의존도는 낮음
  - 코드 중복 등 메모리 효율이 떨어짐
- **동적 라이브러리**
  - 프로그램 실행 시 필요할 때만 DLL의 함수 정보를 참조하여 라이브러리를 사용
  - 메모리 효율이 좋음
  - 외부 의존도가 높아짐
<br/>

---

# 3.3.2 프로세스의 상태
## 생성 상태(create)
- 프로세스가 생성된 상태
- fork()나 exec() 함수를 통해 생성
- 이 때 PCB가 할당된다.
  - fork() : 부모 프로세스의 주소 공간을 그대로 복사해서 새 자식 프로세스를 생성하는 함수. 주소만 복사하기 때문에 부모 프로세스의 비동기 작업 등을 상속하지는 않는다.
  - exec() : 새롭게 프로세스를 생성하는 함수

## 대기 상태(ready)
- 메모리 공간이 충분하면 메모리를 할당받고, 그렇지 않으면 대기
- CPU 스케쥴러로부터 CPU 소유권이 넘어오기를 기다림

## 대기 중단 상태(ready suspended)
- 메모리 부족으로 일시 중단된 상태

## 실행 상태(running)
- CPU 소유권과 메모리를 할당받고 인스트럭션을 수행 중인 상태
- CPU burst가 일어났다고도 표현함

## 중단 상태(blocked)
- 어떤 이벤트가 발생한 이후, 기다리며 프로세스가 차단된 상태
- I/O 인터럽트로 이런 현상이 많이 발생한다.

## 종료 상태(stopped)
- 메모리와 CPU 소유권을 모두 놓고 가는 상태
- 자연 종료 외에도 부모 프로세스가 자식 프로세스를 강제시키는 비자발적 종료(abort)로 종료되는 것도 있음
- 자식 프로세스에 할당된 자원 한계치를 넘거나, 부모 프로세스가 종료되거나 사용자가 process.kill등 명령어로 종료시킬 때 발생함.
