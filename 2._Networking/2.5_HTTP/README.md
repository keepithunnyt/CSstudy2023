# 2.5 HTTP
 - [2.5.1 HTTP/1.0](#251-http10)
   - [RTT 증가 해결법](#rtt-증가-해결법)
- [2.5.2 HTTP/1.1](#252-http11)
  - [HOL Blocking(Head Of Line Blocking)](#hol-blockinghead-of-line-blocking)
- [2.5.3 HTTP/2](#253-http2)
  - [멀티플렉싱](#멀티플렉싱)
  - [헤더 압축](#헤더-압축)
  - [서버 푸시](#서버-푸시)
- [2.5.4 HTTPS](#254-https)
  - [SSL/TLS (Secure Socket Layer / Transport Layer Security Protocol)](#ssltls-secure-socket-layer--transport-layer-security-protocol)
  - [사이퍼 슈트(cypher suites)](#사이퍼-슈트cypher-suites)
  - [인증 메커니즘](#인증-메커니즘)
  - [암호화 알고리즘](#암호화-알고리즘)
  - [해싱 알고리즘](#해싱-알고리즘)
  - [SEO(Search Engine Optimization)에 도움되는 HTTPS](#seosearch-engine-optimization에-도움되는-https)
  - [HTTPS 구축 방법 3가지](#https-구축-방법-3가지)
 - [2.5.5 HTTP/3](#255-http3)
   - [초기 연결 설정 시 지연 감소](#초기-연결-설정-시-지연-감소)


<br/>


---

# 2.5.1 HTTP/1.0
- HTTP/1.0 는 한 연결당 하나의 요청을 처리하도록 설계되었음 (RTT(Round Trip Time) 증가를 불러옴)
  - 서버로부터 파일을 가져올 때마다 3-way 핸드쉐이크를 계속 열어야 함.
  - RTT : 목적지 까지의 패킷 왕복 시간 

## RTT 증가 해결법
  - 이미지 스플리팅 :많은 이미지가 합쳐져 있는 하나의 이미지를 다운받고, background-image의 position을 이용하여 이미지를 표기
  - 코드 압축 : 개행문자, 빈칸을 없애서 코드 크기 최소화
  - base64 인코딩 : 64진법으로 이루어진 문자열로 인코딩하는 방법
    - 장점 : 이미지에 대해 서버에 HTTP 요청을 할 필요 없음
    - 단점 : 용량이 37% 커짐

<br/>

---

# 2.5.2 HTTP/1.1
- 매번 TCP 연결을 하는 것이 아니라, 한 번 TCP 초기화를 한 이후에 Keep-alive라는 옵션으로 여러 파일을 송수신 할 수 있게 함.
  - 1.0에도 Keep-alive는 있었지만 표준화는 1.1 부터 시작
- 문서 안에 포함된 리소스가 많아질수록 개수에 비례해서 대기시간이 길어짐
- 헤더가 쿠키 등 많은 메타데이터를 들고 있고 압축이 되지 않아 많이 무거웠음

## HOL Blocking(Head Of Line Blocking)
- 네트워크 상 같은 큐에 있는 패킷이 첫 번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상



<br/>

---

# 2.5.3 HTTP/2
- HTTP/1.x(SPDY 프로토콜에서 파생됨)보다 지연시간이 짧고 응답시간이 빠름
- 멀티플렉싱, 헤더 압축, 서버 푸시, 요청 우선순위 처리를 지원하는 프로토콜


## 멀티플렉싱
- 여러 개의 스트림을 사용하여 송수신
- 특정 스트림의 패킷이 손실되더라도 나머지 스트림이 정상동작 할 수 있음
  - 스트림(stream) : 시간이 지남에 따라 사용할 수 있게 되는 일련의 데이터 요소
- 하나의 연결에 병렬 스트림을 통해 HOL Blocking을 해결할 수 있다.


## 헤더 압축
- HTTP/2에서 헤더 압축을 해결
  - HTTP/1.x에는 헤더의 크기가 큰 문제가 있었음
- HPack 압축방식 사용(허프만 코딩 알고리즘)

### 허프만 코딩(Huffman coding)
- 문자열을 문자 단위로 쪼개 빈도수를 세어 데이터 표현에 필요한 비트양을 줄임
  - 빈도가 높은 정보는 적은 비트 수를 사용해서 표현

## 서버 푸시
- HTTP/2는 클라이언트 요청 없이 서버가 바로 리소스 푸시 가능(1.1에서는 클라가 요청해야만 파일 다운로드가 가능했다.)


<br/>

---

# 2.5.4 HTTPS
- 애플리케이션 계층과 전송 계층 사이에다 신뢰 게층인 SSL/TLS 계층을 넣은 HTTP 요청 (통신 암호화)
- HTTP/2는 HTTPS 위에서 동작함


## SSL/TLS (Secure Socket Layer / Transport Layer Security Protocol)
- SSL이 1.0부터 2, 3을 거쳐 TLS 1.3까지 버전이 올라가면서 마지막으로 명칭이 TLS가 됨
- 전송 계층에서 보안을 제공(제 3자의 메세지 변조/도청을 막음)
  -  네트워크 인터셉터를 방지
- 보안 세션을 기반으로 데이터 암호화(인증 매커니즘, 키 교환 알고리즘, 해싱 알고리즘 사용)

### 세션
- OS가 유저로부터 자산(프로그램/자원 등) 이용을 허락하는 일정 기간을 뜻한다.


### 보안 세션
- 보안이 시작되고 끝나는 동안 유지되는 세션
- SSL/TLS는 핸드셰이크를 통해 보안 세션을 생성하고 상태 정보 등을 공유한다.
  - 클라와 서버 간 키를 공유하고 인증 확인 작업 시 1-RTT 발생

<br/>

- 클라이언트에서 사이퍼 슈트를 서버에 전달하면, 서버가 받은 사이퍼 슈트의 암호화 알고리즘 리스트를 제공할 수 있는지 확인한다.
- 가능하면 인증 메커니즘이 시작되고 이후 해싱 알고리즘 등으로 암호화된 데이터 송수신이 시작됨


## 사이퍼 슈트(cypher suites)
- 프로토콜, AEAD 사이퍼 모드, 해싱 알고리즘이 나열된 규약을 일컬음
- TLS는 프로토콜, AES_128_GCM는 사이퍼 모드, SHA256은 해싱 알고리즘을 의미
  - TLS_AES_128_GCM_SHA256
  - TLS_AES_256_GCM_SHA384
  - TLS_CHACHA20_POLY1305_SHA256
  - TLS_AES_128_CCM_SHA256
  - TLS_AES_128_CCM_8_SHA256


### AEAD 사이퍼 모드(Authenticated Encryption with Associated Data cypher mode)
- 데이터 암호화 알고리즘
- ex. AES_128_GCM : 128비트의 키를 사용하는 표준 블록 암호화 기술과, 병렬 계산에 용이한 암호화 알고리즘인 GCM이 결합된 알고리즘을 의미

<br/>

## 인증 메커니즘
- CA(Certificate Authorities)에서 발급한 인증서를 기반으로 이루어짐
  - CA 기업 : Comodo, Godaddy, GlobalSign, Amazon 등
- 공개키를 클라에게 제공하고, 사용자가 접속한 서버가 신뢰할 수 있는 서버임을 보장한다.
- 인증서는 서비스 정보, 공개키, 지문, 디지털 서명등으로 이루어져 있다.

### CA 발급 과정
1. 자신의 사이트 정보와 공개키를 CA에 제출한다.
2. CA는 CA인증서를 발급 (CA의 비밀키 기반 - 공개키를 해시한 값인 지문(finger print)을 사용)

- 개인키 : 개인이 소유하고 있는 키이자 비밀키
- 공개키 : 공개되어 있는 키

  <br/>

## 암호화 알고리즘
- 키 교환 암호화 알고리즘 2가지
  - ECDHE(Elliptic Curve Diffie-Hellman Ephermeral) : 대수곡선 기반
  - DHE(Diffie-Hellman Ephermeral) : 모듈식 기반
- 둘 다 Diffie-Hellman 방식 기반이다.

### 디피-헬만 키 교환(Diffie-Hellman key Exchange)
- y = g^x mod p
  - g와 x와 p를 알면 y를 구하기 쉽지만, g, y, p만 알면 x를 구하기 어려운 원리
- 공개 값을 공유하고 이후에 각자의 비밀값과 혼합하여 혼합값을 공유
- 공유받은 혼합값을 각자의 비밀값과 혼합하여 공통의 암호키(PSK : Pre-Shared Key)를 생성한다.

<br/>

## 해싱 알고리즘
- 데이터를 추정하기 어렵게 더 작은 조각으로 조각냄
- SSL/TLS는 SHA-256과 SHA-384를 쓰고, 256이 많이 쓰임

### SHA-256 알고리즘
- 해시 함수의 결괏값이 256비트인 알고리즘
- 블록체인 시스템에서도 사용
- 해싱해야하는 메세지에 1을 추가하여 전처리하고 전처리된 메세지를 기반으로 해시를 반환한다.

- 해시 : 다양한 길이를 가진 데이터를 고정 길이 데이터로 매핑한 값
- 해싱 : 임의의 데이터를 일정한 길이의 데이터(해시)로 바꿔줌. 해시 함수가 해싱 담당.


<br/>

## SEO(Search Engine Optimization)에 도움되는 HTTPS
- HTTPS 서비스를 하는 사이트가 SEO 순위가 높음.
- SEO 관리 방법 : 캐노니컬 설정, 메타 설정, 페이지 속도 개선, 사이트맵 관리


### 캐노니컬 설정
- 사이트 링크에 캐노니컬 설정 예시
```html
<link rel="cannonical" href="https://example.com/page.php" />
```

### 메타 설정
- HTML 가장 윗부분에 메타 설정을 잘해야 한다.

### 페이지 속도 개선
 - 구글의 Page Speed Insights에 가서 자신의 서비스에 대한 리포팅을 주기적으로 받으며 관리해야 함.

### 사이트맵 관리
- 사이트맵 : 검색 엔진 크롤링 로봇에게 웹 사이트에서 크롤링 해야 할 URL 을 전달한다.
- XML 형태이며 URL과 콘텐츠의 최종 업데이트 시점 및 업데이트 빈도, 그리고 다른 URL 대비 상대적인 중요도 정보를 담을 수 있다.
- 사이트 맵을 지원하는 검색 엔진은 이 정보를 사용하여 웹 사이트 크롤링을 보다 효율적으로 할 수 있음
- 사이트 맵은 검색 엔진에 URL을 추가 혹은 배제하는 규약으로서 로봇 텍스트 파일을 보완하는 역할을 함.
- Sitemap.xml파일은 사이트 콘텐츠의 변화에 맞춰 늘 업데이트 되어야하므로 수동으로 관리하기 보다는 가능한 사이트의 변화에 따라 매일 자동으로 업데이트 되도록 하는 것이 좋다.

<br/>

## HTTPS 구축 방법 3가지
1. CA에서 직접 구매한 인증키를 기반으로 HTTPS 서비스를 구축
2. HTTPS를 제공하는 로드밸런서를 서버 앞단에 둠
3. 서버 앞단에 HTTPS를 제공하는 CDN을 둠

<br/>

---

# 2.5.5 HTTP/3
- QUIC이라는 계층 위에서 돌아감
- UDP
- HTTP/2와 마찬가지로 멀티플렉싱이 있음
- 초기 연결 설정 시 지연 감소 장점이 있음

## 초기 연결 설정 시 지연 감소
- TCP를 사용하지 않기 때문에 번거로운 3-way hand shake 과정이 없다.
- QUIC는 첫 연결에 1-RTT만 소요한다.
  - FEC(Forward Error Correction) 적용
    - 오류 수정 메커니즘
    - 전송한 패킷이 손실되었다면 수신 측에서 에러 검출 및 수정
    - 나쁜 네트워크 환경에서도 패킷 손실률이 낮음